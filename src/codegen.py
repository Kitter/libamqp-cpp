from amqp_codegen import *

def sanitizeName(specName):
    if specName == 'delete':
        specName = 'delete_'
    if specName == 'return':
        specName = 'return_'
    res = specName.replace('-', '_')
    res = res.replace(' ', '_')
    return res

types = {
       'octet':'uint8_t',
       'short':'uint16_t',
       'long':'uint32_t',
       'longlong':'uint64_t',
       'shortstr':'std::string',
       'longstr':'std::string',
       'bit':'bool',
       'table':'table',
       'timestamp':'uint64_t'
       }



def genHeader(spec):

    def genGetter(field):
        amqp_type = spec.resolveDomain(field.domain)
        name = sanitizeName(field.name)
        if (amqp_type == 'table'):
            print "    inline table& get_%s() { return m_%s; }" % (name, name)
            print "    inline const table& get_%s() const { return m_%s; }" % (name, name)
        else:
            type = types[amqp_type]
            print "    inline %s get_%s() const { return m_%s; }" % (type, name, name)

    def genSetter(field):
        amqp_type = spec.resolveDomain(field.domain)
        name = sanitizeName(field.name)
        if (amqp_type == 'table'):
            pass
        elif (amqp_type == 'shortstr'):
            print "    inline void set_%s(const std::string& s) { detail::validate_shortstring(s); m_%s = s; }" % (name, name)
        elif (amqp_type == 'longstr'):
            print "    inline void set_%s(const std::string& s) { detail::validate_shortstring(s); m_%s = s; }" % (name, name)
        else:
            type = types[amqp_type]
            print "    inline void set_%s(%s v) { m_%s = v; }" % (name, type, name)

    print """// Autogenerated code. Do not edit. Edit codegen.py instead

#ifndef _LIBAMQPP_METHODS_GEN_H_INCLUDED_
#define _LIBAMQPP_METHODS_GEN_H_INCLUDED_

#include "methods.h"
#include "table.h"

#include <boost/cstdint.hpp>
#include <boost/shared_ptr.hpp>

#include <iosfwd>
#include <string>

namespace amqpp
{
"""
    for c in spec.classes :
        print "namespace %s" % (c.name)
        print "{"
        print "  enum { CLASS_ID = %d };" % (c.index)
        for m in c.methods:
            method_name = sanitizeName(m.name)
            print "  class %s : public detail::method" % (method_name)
            print "  {"
            print "  public:"
            print "    enum { METHOD_ID = %d };" % (m.index)
            print "    virtual uint16_t class_id() const { return %s::CLASS_ID; }" % (c.name)
            print "    virtual uint16_t method_id() const { return %s::METHOD_ID; }" % (method_name)
            print ""
            print "    static boost::shared_ptr<%s> read(std::istream& i);" % (method_name)
            print "    virtual void write(std::ostream& o) const;"
            print "    virtual std::string to_string() const;"
            for f in m.arguments:
                genGetter(f)
                genSetter(f)
            print ""
            print "  private:"
            for f in m.arguments:
                print "    %s m_%s;" % (types[spec.resolveDomain(f.domain)], sanitizeName(f.name))
            print "  };"
            print ""
        print "} //namespace %s" % (c.name)
        print ""

    print """} // namespace amqpp
#endif // _LIBAMQPP_METHODS_GEN_H_INCLUDED_
"""

def genBody(spec):
    reader_writer = {
                     'octet':'uint8',
                     'short':'uint16',
                     'long':'uint32',
                     'longlong':'uint64',
                     'shortstr':'shortstring',
                     'longstr':'longstring',
                     'bit':'',
                     'table':'table',
                     'timestamp':'uint64'
                     }

    def getBitsLength(index, arguments):
        start = index
        while start > 0 and 'bit' == spec.resolveDomain(arguments[start - 1].domain):
            start -= 1
            
        end = index
        while end < len(arguments) and 'bit' == spec.resolveDomain(arguments[end].domain):
            end += 1
        
        return end - start
    
    def getBitsNumber(index, arguments):
        start = index
        while start > 0 and 'bit' == spec.resolveDomain(arguments[start - 1].domain):
            start -= 1
            
        return index - start
    
    def getBitfieldSize(length):
        if length <= 8:
            return 8
        elif length <=16:
            return 16
        elif length <= 32:
            return 32
        elif length <= 64:
            return 64
        else:
            raise Exception
        
    def genPrintFunction(method):
        method_name = sanitizeName(method.name)
        print "std::string %s::to_string() const" % (method_name)
        print "{"
        print "  std::ostringstream o;"
        print '  o << "class: %s<%d> method: %s<%d> {";' % (method.klass.name, method.klass.index, method.name, method.index)
        for field in method.arguments:
            domain = spec.resolveDomain(field.domain)
            if 'shortstr' == domain or 'longstr' == domain:
                print '  o << "%s<%s>: " << detail::print_string(get_%s()) << " ";' % (field.name, domain, sanitizeName(field.name))
            elif 'table' == domain:
                print '  o << "%s<%s>: " << get_%s().to_string() << " ";' % (field.name, domain, sanitizeName(field.name))
            else:
                print '  o << "%s<%s>: " << get_%s() << " ";' % (field.name, domain, sanitizeName(field.name))
        print '  o << "}";'
        print "  return o.str();"
        print "}"

    def genReadBits(index, field, arguments):
        bit_number = getBitsNumber(index, arguments)
        bit_length = getBitsLength(index, arguments)
        bitsfield_length = getBitfieldSize(bit_length)
        if 0 == bit_number:
            print "  {"
            print "    uint%d_t bits = detail::wireformat::read_uint%d(i);" % (bitsfield_length, bitsfield_length)
        print "    ptr->set_%s(detail::get_bit(bits, %d));" % (sanitizeName(field.name), bit_number)
        if bit_number == (bit_length - 1):
            print "  }"
        
    def genReadFunction(method):
        method_name = sanitizeName(method.name)
        print "boost::shared_ptr<%s> %s::read(std::istream& i)" % (method_name, method_name)
        print "{"
        print "  boost::shared_ptr<%s> ptr = boost::make_shared<%s>();" % (method_name, method_name)
        for index, field in enumerate(method.arguments):
            domain = spec.resolveDomain(field.domain)
            if domain == 'bit':
                genReadBits(index, field, method.arguments)
            elif domain == 'table':
                print "  ptr->get_%s() = detail::wireformat::read_table(i);" % (sanitizeName(field.name))
            else:
                print "  ptr->set_%s(detail::wireformat::read_%s(i));" % (sanitizeName(field.name), reader_writer[domain])
        print "  return ptr;"
        print "}"

        
        
    def genWriteBits(index, field, arguments):
        bit_number = getBitsNumber(index, arguments)
        bit_length = getBitsLength(index, arguments)
        bitfield_length = getBitfieldSize(bit_length)
        if 0 == bit_number:
            print "  {"
            print "    uint%d_t bits = 0;" % (bitfield_length)
        print "    bits = detail::set_bit(bits, m_%s, %d);" % (sanitizeName(field.name), bit_number)
        if bit_number == (bit_length - 1):
            print "    detail::wireformat::write_uint%d(o, bits);" % (bitfield_length)
            print "  }"
            
    
    def genWriteFunction(method):
        method_name = sanitizeName(method.name)
        print "void %s::write(std::ostream& o) const" % (method_name)
        print "{"
        print "  detail::wireformat::write_uint16(o, static_cast<uint16_t>(%s::CLASS_ID));" % (method.klass.name)
        print "  detail::wireformat::write_uint16(o, static_cast<uint16_t>(%s::METHOD_ID));" % (method_name)
        for index, field in enumerate(method.arguments):
            domain = spec.resolveDomain(field.domain)
            if domain == 'bit':
                genWriteBits(index, field, method.arguments)
            else:
                print "  detail::wireformat::write_%s(o, m_%s);" % (reader_writer[domain], sanitizeName(field.name))
        print "}"
        return


    print """// Autogenerated code. Do not edit. Edit codegen.py instead
#include "methods.gen.h"
#include "wireformat.h"

#include <boost/make_shared.hpp>

#include <istream>
#include <ostream>
#include <sstream>

namespace amqpp
{
"""
    for c in spec.classes :
        print "namespace %s" % (c.name)
        print "{"
        for m in c.methods:
            genPrintFunction(m)
            print ""
            genReadFunction(m)
            print ""
            genWriteFunction(m)
            print ""
        print "} // namespace %s" % (c.name)

    print """
} //namespace amqpp
"""


def generateHeader(specPath):
    genHeader(AmqpSpec(specPath))

def generateSource(specPath):
    genBody(AmqpSpec(specPath))

if __name__ == "__main__":
    do_main(generateHeader, generateSource)
