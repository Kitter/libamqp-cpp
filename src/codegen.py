from amqp_codegen import *

def sanitizeName(specName):
    if specName == 'delete':
        specName = 'delete_'
    if specName == 'return':
        specName = 'return_'
    res = specName.replace('-', '_')
    res = res.replace(' ', '_')
    return res

types = {
       'octet':'uint8_t',
       'short':'uint16_t',
       'long':'uint32_t',
       'longlong':'uint64_t',
       'shortstr':'std::string',
       'longstr':'std::string',
       'bit':'bool',
       'table':'table',
       'timestamp':'uint64_t'
       }



def genHeader(spec):

    def genGetter(field):
        amqp_type = spec.resolveDomain(field.domain)
        name = sanitizeName(field.name)
        if (amqp_type == 'table'):
            print "    inline table& get_%s() { return m_%s; }" % (name, name)
            print "    inline const table& get_%s() const { return m_%s; }" % (name, name)
        else:
            type = types[amqp_type]
            print "    inline %s get_%s() const { return m_%s; }" % (type, name, name)

    def genSetter(field):
        amqp_type = spec.resolveDomain(field.domain)
        name = sanitizeName(field.name)
        if (amqp_type == 'table'):
            pass
        elif (amqp_type == 'shortstr'):
            print "    inline void set_%s(const std::string& s) { detail::validate_shortstring(s); m_%s = s; }" % (name, name)
        elif (amqp_type == 'longstr'):
            print "    inline void set_%s(const std::string& s) { detail::validate_shortstring(s); m_%s = s; }" % (name, name)
        else:
            type = types[amqp_type]
            print "    inline void set_%s(%s v) { m_%s = v; }" % (name, type, name)

    print """// Autogenerated code. Do not edit. Edit codegen.py instead

#ifndef _LIBAMQPP_METHODS_GEN_H_INCLUDED_
#define _LIBAMQPP_METHODS_GEN_H_INCLUDED_

#include "methods.h"
#include "table.h"

#include <boost/cstdint.hpp>
#include <boost/shared_ptr.hpp>

#include <iosfwd>
#include <string>

namespace amqpp
{
"""
    for c in spec.classes :
        print "namespace %s" % (c.name)
        print "{"
        print "  enum { CLASS_ID = %d };" % (c.index)
        for m in c.methods:
            method_name = sanitizeName(m.name)
            print "  class %s : public detail::method" % (method_name)
            print "  {"
            print "  public:"
            print "    enum { METHOD_ID = %d };" % (m.index)
            print "    virtual uint16_t class_id() const { return %s::CLASS_ID; }" % (c.name)
            print "    virtual uint16_t method_id() const { return %s::METHOD_ID; }" % (method_name)
            print ""
            print "    static boost::shared_ptr<%s> read(std::istream& i);" % (method_name)
            print "    virtual void write(std::ostream& o) const;"
            print "    virtual std::string to_string() const;"
            for f in m.arguments:
                genGetter(f)
                genSetter(f)
            print ""
            print "  private:"
            for f in m.arguments:
                print "    %s m_%s;" % (types[spec.resolveDomain(f.domain)], sanitizeName(f.name))
            print "  };"
            print ""
        print "} //namespace %s" % (c.name)
        print ""

    print """} // namespace amqpp
#endif // _LIBAMQPP_METHODS_GEN_H_INCLUDED_
"""

def genBody(spec):
    reader_writer = {
                     'octet':'uint8',
                     'short':'uint16',
                     'long':'uint32',
                     'longlong':'uint64',
                     'shortstr':'shortstring',
                     'longstr':'longstring',
                     'bit':'',
                     'table':'table',
                     'timestamp':'uint64'
                     }

    def genPrintFunction(method):
        method_name = sanitizeName(method.name)
        print "std::string %s::to_string() const" % (method_name)
        print "{"
        print "  return std::string();"
        print "}"

    def genReadFunction(method):
        method_name = sanitizeName(method.name)
        print "boost::shared_ptr<%s> %s::read(std::istream& i)" % (method_name, method_name)
        print "{"
        print "  return boost::shared_ptr<%s>();" % (method_name)
        print "}"

    def genWriteFunction(method):
        method_name = sanitizeName(method.name)
        print "void %s::write(std::ostream& o) const" % (method_name)
        print "{"
        print "  detail::wireformat::write_uint16(o, static_cast<uint16_t>(%s::CLASS_ID));" % (method.klass.name)
        print "  detail::wireformat::write_uint16(o, static_cast<uint16_t>(%s::METHOD_ID));" % (method_name)
        for f in method.arguments:
            print "  detail::wireformat::write_%s(o, m_%s);" % (reader_writer[spec.resolveDomain(f.domain)], sanitizeName(f.name))
        print "}"
        return


    print """// Autogenerated code. Do not edit. Edit codegen.py instead
#include "methods.gen.h"
#include "wireformat.h"

#include <boost/make_shared.hpp>

#include <istream>
#include <ostream>

namespace amqpp
{
"""
    for c in spec.classes :
        print "namespace %s" % (c.name)
        print "{"
        for m in c.methods:
            genPrintFunction(m)
            print ""
            genReadFunction(m)
            print ""
            genWriteFunction(m)
            print ""
        print "} // namespace %s" % (c.name)

    print """
} //namespace amqpp
"""


def generateHeader(specPath):
    genHeader(AmqpSpec(specPath))

def generateSource(specPath):
    genBody(AmqpSpec(specPath))

if __name__ == "__main__":
    do_main(generateHeader, generateSource)
